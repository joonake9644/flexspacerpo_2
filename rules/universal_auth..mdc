============================================================================
// UNIVERSAL AUTHENTICATION CONSISTENCY PRINCIPLES
// ============================================================================
// Technology-agnostic guidelines for building robust authentication systems.
// Focus on core patterns and principles rather than specific implementations.
//
// APPLIES TO: Firebase Authentication system
// PHILOSOPHY: "Secure by design, fail gracefully, guide users clearly"
// ============================================================================

/**
 * @fileoverview Universal authentication patterns that prevent common security
 * and UX issues regardless of technology stack or implementation details.
 */

// ============================================================================
// CORE AUTHENTICATION PRINCIPLES
// ============================================================================

/**
 * Universal User States - Every auth system needs these
 */
export enum UserState {
  /** Needs some action before full access */
  PENDING = 'PENDING',
  
  /** Full access granted */
  ACTIVE = 'ACTIVE',
  
  /** Temporarily restricted */
  RESTRICTED = 'RESTRICTED',
  
  /** Permanently disabled */
  DISABLED = 'DISABLED'
}

/**
 * Operation Risk Assessment - Choose your protection level
 */
export enum AuthRisk {
  /** Account security operations (password change, deletion) */
  CRITICAL = 'CRITICAL',
  
  /** Core auth operations (login, signup, verification) */
  HIGH = 'HIGH',
  
  /** Supporting operations (password reset request, profile update) */
  MEDIUM = 'MEDIUM',
  
  /** Read operations (session check, profile view) */
  LOW = 'LOW'
}

// ============================================================================
// PRINCIPLE 1: ATOMIC USER OPERATIONS
// ============================================================================

/**
 * Core Pattern: All-or-Nothing User Creation
 * Problem: Partial user records when signup fails midway
 * Solution: Complete success or complete rollback
 */
export const ATOMIC_USER_CREATION = {
  PRINCIPLE: 'Either user is fully created or not created at all',
  
  STEPS: [
    '1. Validate all input data upfront',
    '2. Check for conflicts (existing email, username)', 
    '3. Create user record in transaction/atomic operation',
    '4. Initialize related records (profile, preferences)',
    '5. Send verification if required',
    '6. On any failure: clean up ALL created records'
  ],
  
  SUCCESS_CRITERIA: [
    'User record exists in database',
    'All required related records created',
    'User state is consistent',
    'Verification sent if needed'
  ],
  
  FAILURE_HANDLING: [
    'No partial user records left in system',
    'Clear error message to user',
    'Log error for debugging',
    'Allow user to retry safely'
  ]
} as const

/**
 * Implementation Template (adapt to your technology)
 */
export const atomicUserCreationPattern = {
  PSEUDO_CODE: `
    function createUser(userData) {
      let createdRecords = []
      
      try {
        // Validate first
        validateInput(userData)
        checkForDuplicates(userData.email)
        
        // Create atomically  
        transaction.begin()
        userId = transaction.createUser(userData)
        transaction.createProfile(userId)
        transaction.createPreferences(userId)
        transaction.commit()
        
        // Post-creation actions
        if (needsVerification) sendVerificationEmail(userId)
        
        return success(userId)
        
      } catch (error) {
        transaction.rollback()
        cleanupAnyPartialRecords(createdRecords)
        return failure(getUserFriendlyMessage(error))
      }
    }
  `
}

// ============================================================================
// PRINCIPLE 2: STATE-AWARE AUTHENTICATION
// ============================================================================

/**
 * Core Pattern: Check User State Before Allowing Actions
 * Problem: Users in invalid states (unverified, locked) can access system
 * Solution: Validate user state at authentication gates
 */
export const STATE_AWARE_AUTH = {
  PRINCIPLE: 'Always validate user state before granting access',
  
  GATES: [
    'Login attempt → Check if user can login',
    'Password reset → Check if account is active',
    'Email verification → Check if verification is needed',
    'Profile access → Check if account is in good standing'
  ],
  
  VALIDATION_ORDER: [
    '1. Does user exist?',
    '2. Is account in valid state for this operation?', 
    '3. Are credentials correct?',
    '4. Are there any restrictions or requirements?',
    '5. Grant access or provide clear guidance'
  ]
} as const

/**
 * State Validation Decision Tree
 */
export const stateValidationRules = {
  LOGIN_ATTEMPT: {
    PENDING: 'Redirect to verification flow',
    ACTIVE: 'Allow login if credentials valid',
    RESTRICTED: 'Show restriction reason, offer help',
    DISABLED: 'Show account disabled message'
  },
  
  PASSWORD_RESET: {
    PENDING: 'Allow reset, will activate account',
    ACTIVE: 'Allow normal reset flow',
    RESTRICTED: 'Allow reset but warn about restrictions', 
    DISABLED: 'Deny reset, direct to support'
  },
  
  PROFILE_ACCESS: {
    PENDING: 'Limited access, show verification prompt',
    ACTIVE: 'Full access',
    RESTRICTED: 'Limited access with explanation',
    DISABLED: 'No access'
  }
}

// ============================================================================
// PRINCIPLE 3: GRACEFUL ERROR HANDLING
// ============================================================================

/**
 * Core Pattern: Fail Safely with Clear Guidance
 * Problem: Users get stuck with unclear errors or system breaks
 * Solution: Anticipate failures and provide recovery paths
 */
export const GRACEFUL_ERROR_HANDLING = {
  PRINCIPLE: 'Every error should help user succeed next time',
  
  ERROR_RESPONSE_STRUCTURE: {
    success: 'boolean - operation result',
    errorCode: 'string - for programmatic handling', 
    userMessage: 'string - clear, actionable guidance',
    nextAction: 'string - what user should do next',
    retryable: 'boolean - is it safe to retry?'
  },
  
  SECURITY_CONSIDERATIONS: [
    'Don\'t reveal if email exists (during password reset)',
    'Generic "invalid credentials" for login failures',
    'Don\'t expose internal system details',
    'Rate limit error-prone operations'
  ]
} as const

/**
 * Standard Error Categories and Responses
 */
export const errorResponsePatterns = {
  USER_INPUT_ERRORS: {
    pattern: 'Validation failed',
    userMessage: 'Specific field error with correction guidance',
    nextAction: 'Fix input and retry',
    retryable: true
  },
  
  AUTHENTICATION_ERRORS: {
    pattern: 'Credentials invalid',
    userMessage: 'Generic message for security',
    nextAction: 'Try again or reset password',
    retryable: true
  },
  
  ACCOUNT_STATE_ERRORS: {
    pattern: 'Account not ready',
    userMessage: 'Clear explanation of account status',
    nextAction: 'Specific guidance (verify email, contact support)',
    retryable: false
  },
  
  SYSTEM_ERRORS: {
    pattern: 'System unavailable', 
    userMessage: 'Apologetic message with timeline if known',
    nextAction: 'Try again later or contact support',
    retryable: true
  }
}

// ============================================================================
// PRINCIPLE 4: PROGRESSIVE SECURITY
// ============================================================================

/**
 * Core Pattern: Adapt Security to Risk Level
 * Problem: Same security for all operations (too strict or too loose)
 * Solution: Match security measures to operation risk
 */
export const PROGRESSIVE_SECURITY = {
  PRINCIPLE: 'Security measures should match the risk level',
  
  RISK_BASED_CONTROLS: {
    CRITICAL: [
      'Require recent authentication',
      'Multi-factor authentication if available',
      'Additional confirmation step',
      'Audit logging',
      'Rate limiting'
    ],
    
    HIGH: [
      'Strong input validation',
      'Attempt limiting',
      'Clear audit trail', 
      'User notification of changes'
    ],
    
    MEDIUM: [
      'Basic input validation',
      'Simple rate limiting',
      'Standard error handling'
    ],
    
    LOW: [
      'Basic security headers',
      'Input sanitization',
      'Normal monitoring'
    ]
  }
} as const

// ============================================================================
// COMMON AUTHENTICATION FLOWS
// ============================================================================

/**
 * Flow 1: User Registration
 */
export const REGISTRATION_FLOW = {
  CRITICAL_CHECKPOINTS: [
    'Input validation before any processing',
    'Duplicate account detection', 
    'Atomic user creation with rollback',
    'Appropriate initial user state',
    'Verification process if needed'
  ],
  
  SUCCESS_OUTCOMES: [
    'User can proceed to verification or login',
    'Clear next steps communicated',
    'System state is consistent',
    'User has realistic expectations'
  ],
  
  FAILURE_HANDLING: [
    'No partial accounts in system',
    'User understands what went wrong',
    'Safe to retry registration',
    'Errors are logged for improvement'
  ]
}

/**
 * Flow 2: User Login
 */
export const LOGIN_FLOW = {
  CRITICAL_CHECKPOINTS: [
    'User existence check',
    'Account state validation',
    'Credential verification',
    'Failed attempt tracking',
    'Session creation'
  ],
  
  SECURITY_MEASURES: [
    'Rate limiting per IP and per account',
    'Account lockout after repeated failures',
    'Generic error messages',
    'Audit logging of attempts'
  ]
}

/**
 * Flow 3: Email Verification
 */
export const VERIFICATION_FLOW = {
  CRITICAL_CHECKPOINTS: [
    'Token validation (format, expiry, authenticity)',
    'User state verification',
    'Idempotent operation (safe to repeat)',
    'Clear success/failure messaging'
  ],
  
  USER_EXPERIENCE: [
    'Clear instructions in verification email',
    'Obvious resend option',
    'Help if verification fails',
    'Seamless transition to next step'
  ]
}

/**
 * Flow 4: Password Reset
 */
export const PASSWORD_RESET_FLOW = {
  SECURITY_FIRST: [
    'No email enumeration (same response for valid/invalid emails)',
    'Secure token generation and validation',
    'Token expiry (typically 15-60 minutes)', 
    'Invalidate all sessions after successful reset'
  ],
  
  USER_GUIDANCE: [
    'Clear timeline expectations',
    'Check spam folder reminder',
    'Alternative contact if email fails',
    'Security reassurance about the process'
  ]
}

// ============================================================================
// IMPLEMENTATION GUIDELINES BY TECHNOLOGY
// ============================================================================

/**
 * Technology-Agnostic Patterns
 */
export const TECH_AGNOSTIC_PATTERNS = {
  DATABASE_OPERATIONS: {
    USER_CREATION: 'Use transactions/atomic operations',
    STATE_UPDATES: 'Update with timestamp and audit info',
    FAILED_ATTEMPTS: 'Increment counters with reset logic',
    SESSION_MANAGEMENT: 'Secure storage with expiration'
  },
  
  EMAIL_OPERATIONS: {
    VERIFICATION: 'Secure token in URL, clear call-to-action',
    PASSWORD_RESET: 'Time-limited token, security messaging',
    NOTIFICATIONS: 'Inform about account changes',
    TEMPLATES: 'Consistent branding, mobile-friendly'
  },
  
  CLIENT_SIDE: {
    INPUT_VALIDATION: 'Immediate feedback, server validation backup',
    ERROR_DISPLAY: 'User-friendly messages, retry options',
    LOADING_STATES: 'Show progress, prevent double-submission',
    FORM_HANDLING: 'Preserve data on errors, guide corrections'
  }
}

/**
 * Adaptation Guide for Different Stacks
 */
export const STACK_ADAPTATIONS = {
  FIREBASE_AUTH: {
    leverage: ['Built-in email verification', 'Social providers', 'Security rules'],
    supplement: ['Custom user states', 'Business logic validation', 'Audit logging']
  },
  
  AUTH0: {
    leverage: ['Rules/hooks', 'Management API', 'Multi-tenancy'],
    supplement: ['Custom flows', 'Additional user data', 'Business rules']
  },
  
  SUPABASE_AUTH: {
    leverage: ['Row Level Security', 'Database integration', 'Real-time updates'],
    supplement: ['Complex business logic', 'Custom email templates', 'Advanced flows']
  },
  
  CUSTOM_AUTH: {
    implement: ['All security measures', 'Token management', 'Email delivery'],
    consider: ['Use established libraries', 'Regular security updates', 'Performance optimization']
  }
}

// ============================================================================
// VALIDATION AND MONITORING
// ============================================================================

/**
 * Essential Validation Rules (adapt to your requirements)
 */
export const VALIDATION_ESSENTIALS = {
  EMAIL: 'Format validation, reasonable length limits',
  PASSWORD: 'Minimum strength requirements, not common passwords',
  USER_DATA: 'Required fields, data type validation, length limits',
  TOKENS: 'Format validation, expiry check, authenticity verification'
}

/**
 * Monitoring and Alerting (adapt to your tools)
 */
export const MONITORING_ESSENTIALS = {
  TRACK_ALWAYS: [
    'Failed login attempts by user and IP',
    'Account creation success/failure rates',
    'Email delivery success rates',
    'Password reset request patterns'
  ],
  
  ALERT_CONDITIONS: [
    'Unusual failed login patterns',
    'High account creation failure rate',
    'Email delivery failures',
    'Potential security attacks'
  ]
}

// ============================================================================
// IMPLEMENTATION CHECKLIST
// ============================================================================

/**
 * Start Here: Minimum Viable Auth Security
 */
export const MVP_AUTH_CHECKLIST = {
  FOUNDATION: [
    '✅ Atomic user creation with rollback',
    '✅ User state validation before operations',
    '✅ Clear error messages and next steps',
    '✅ Basic rate limiting on auth endpoints'
  ],
  
  SECURITY_ESSENTIALS: [
    '✅ Failed attempt tracking and limits', 
    '✅ Secure password requirements',
    '✅ Email verification for new accounts',
    '✅ Secure password reset flow'
  ],
  
  USER_EXPERIENCE: [
    '✅ Loading states during auth operations',
    '✅ Helpful error messages with guidance',
    '✅ Easy verification email resend',
    '✅ Clear account state communication'
  ]
}

/**
 * Common Mistakes to Avoid (Universal)
 */
export const UNIVERSAL_AUTH_MISTAKES = [
  'Creating partial user records that survive failures',
  'Allowing operations without checking user state', 
  'Exposing system internals in error messages',
  'Not rate limiting authentication endpoints',
  'Ignoring failed authentication attempt patterns',
  'Making password reset reveal email existence',
  'Not providing clear guidance when operations fail',
  'Forgetting to invalidate sessions after password changes',
  'Not logging security-relevant events',
  'Using weak or predictable token generation'
] as const

// ============================================================================
// QUICK DECISION GUIDES  
// ============================================================================

/**
 * 30-Second Decision Guide
 */
export const QUICK_AUTH_DECISIONS = {
  CHOOSE_RISK_LEVEL: [
    'Password change, account deletion → CRITICAL',
    'Login, signup, email verification → HIGH',
    'Password reset request, profile update → MEDIUM', 
    'Session check, public profile view → LOW'
  ],
  
  ERROR_HANDLING: [
    'Can user fix this? → Specific guidance',
    'Security sensitive? → Generic message',
    'System problem? → Apologetic message + timeline',
    'User fault? → Educational message'
  ],
  
  STATE_VALIDATION: [
    'Does this operation require verified email? → Check verification',
    'Could account be locked/suspended? → Check state',
    'Is this a privileged operation? → Check permissions',
    'Should we track this attempt? → Log appropriately'
  ]
} as const
